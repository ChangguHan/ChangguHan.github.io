---
title:  "슬기로운 쿼리생활"

categories:
- Blog
  tags:
- Blog
---
### NHN 베이스캠프 기초 교육 정리
- 주제 : SQL 이론 및 쿼리 검수 결과 공유
- 교육일자 : 2021.03.10
- 발표자 : NHN 남준 선임
- 주최 : NHN 베이스캠프 운영팀

### 테이블 작성
- 데이터 타입은 최대한 작게 설계
    - 0,1만 저장하는 컬럼이 있을 때
    - 최적 : tinyint(0,1 저장),  1바이트
    - int : 4바이트
        - 3바이트의 공간 낭비
        - 데이터 적을때는 문제가 없지만, 1억개의 tuple이 있을경우, 300메가의 디스크가 낭비되게됨
    - char(1) 1바이트 : Y,M 저장, 직관적
- not null 속성이 확실할때만 적용
    - default는 null 허용
    - mysql은 null 허용시 각 로우에서 컬럼당 1바이트 추가로 사용
    - 데이터 낭비 줄일수 있으면 줄일 수 있는게 좋음
    
### 쿼리 작성
- select 절에는 필요한 컬럼만 작성
    - 불필요한 자원이 소모됨
    - 컬럼 추가, 삭제 시 문제 발생
    - 예시
        - select * ~ : X
        - select movie_id, title ~ : O
- 비교 시 컬럼의 데이터 타입과 일치하도록 조회
    - 안맞출경우 풀테이블 스캔이 발생해 느려짐
    - 예시
        - where num_column=1000 : O
        - where num_column=‘1000’ : X
- now() vs sysdate()
    - now()
        - 쿼리 실행 전, 시간 후가 동일
    - sysdate()
        - 호출될때의 순간을 반환
        - 쿼리 실행 전 후가 다름
    - sysdate()는 슬레이브에 안정적으로 복제 불가능
        - 그래서 sysdate()는 호출되는 시점에서의 반환이 됨
        - sysdate()와 비교되는 컬럼은 인덱스를 효율적으로 사용하지 못함
### 인덱스 사용시 주의
- Cardinality
    - 인덱싱 된 컬럼의 유니크한 값 수 (즉 이 컬럼에 유니크한 값이 몇개로 분류되는지)
    - 확인법 : show index from reservation;
        - 이중 cardinality 값 확인
        - 단 이는 8개의 페이지 샘플링으로 통계된 근사값임
- 결합 인덱스 사용 시 고려
    - equal 조건을 좌측, range 조건을 우측 배치
    - equal 로 범위를 줄여서 검색한 뒤,
    - 범위가 넓은것일 수록 더 많은 것을 봐야함
- join 절의 on에 해당하는 컬럼에 인덱스 추가
    - 인덱스 없을경우 부하가 많이 발생(풀 테이블 스캔)
    - mysql은 생성된 인덱스를 활용
    - 또한 데이터타입도 동일해야함
    - 예시
        - 식당 테이블과 예약 테이블이 식당아이디 컬럼으로 조인될 경우
        - 식당아이디 컬럼에 인덱스가 없으면 풀테이블 스캔
- 인덱스도 비용
    - 데이터와 마찬가지로 공간 차지
    - 인덱스 많아질경우, CUD는 느려짐
    - 최소한의 인덱스를 생성
- 좌변에 메소드를 적용하거나 변경하면 인덱스 사용 불가
    - where date_format(create_dt,’%Y~’) =’20210309’
    - 날짜가 같은 값을 찾을때는 구간값으로 찾아줌
- 형변환
    - 숫자가 우선시됨, char > 숫자
        - order_no : bigint(20) 일떄
        - where orrder_no = ‘1’ > 우측이 자동으로 형변환 발생
        - order_status_cd : varcahr(5)일때
        - where ordr_statuscd = 10 > 좌측이 자동으로 형변환
    - 날짜 형태 스트링은 는 묵시적으로 데이트 타입 형변환
        - ordr_ymdt=‘2011-02-17’ > 우측에서 형변환되어 자동으로 형변환
    - 보통 데이터 타입 맞춰서 작성하는 것이 깔끔
- LIKE
    - 와일드카드를 뒤쪽에 입력시 인덱스 레인지 스캔 가능
        - like ‘검색어%’ : O
    - 검색 앞쪽에는 스캔 불가
        - like ‘%검색어’ : X
    - 하지만 방법이 없을 경우 보통 그냥 사용
- order by a ASC, b DESC
    - MYSQL은 5.7까지 desc 인덱스 지원되지 않음
    - ddl에는 실행되지만 상위버전과의 호환성을 위한것으로 ascending으로만 생성 가능
    - asc로 생성되지만 인덱스 스캔 방향은 양방향이므로 단일 컬럼의 desc는 문제없음
    - 예시
        -  order by A asc, B asc : 인덱스 활용 가능
        - asc asc or desc, desc : 인덱스 활용 가능
        - asc desc는 인덱스 활용 불가
### 실행계획
- 확인 방법
    - 쿼리 앞에 explain을 붙여서 확인가능
    - 쿼리 작성 후 실행계획을 한번씩 확인하는 것이 좋은 습관
- 확인해야 할 항목
    - 쿼리 실행 시간
    - 컬럼 type
        - ALL : 테이블 풀 스캔
        - INDEX : 인덱스 풀스캔(인덱스를 처음부터 끝까지 읽음)
            - 테이블 풀스캔보다는 낫지만. 그렇게 좋은건 아님
    - 컬럼 rows
        - 참조되는 rows 수
        - 튜닝하면서 rows를 줄여나가야함
    - 컬럼 extra
        - using temporary : 임시 테이블, 성능 저하되는 경우가 많음
        - using filesort : 정렬작업이 적용, 비용이 많이 드는 작업
        - using join buffer : join 할 때, join key에 인덱스 없을때 발생
        - using where : 조건 사용해서 row를 제한
        - using index : 인덱스를 사용해서 조건을 적용
            - 성능이 좋은 쿼리임을 의미
    - key_len
        - 인덱스에서 어떤 컬럼까지 활용했는지 알수 있는 정보
        - 바이트수로 표시됨
        - 널 허용시 1바이트 추가 등 있음
- explain format=tree
    - 실행할 경우 보기 편한 실행 계획 확인 가능
### 각 TF별 쿼리 리뷰
- select 절에 필요한 컬럼 만 명시
    - 조인되는 컬럼은 하나만 가져오기
    - 예시 : select a.a, b.a from tableA a left join tableB b on a.a = b.a
- 적절한 join 종류 선택
    - innter, outer, cross를 구조 파악해 적절한 조인 방법 선택
    - inner 조인사용하는 케이스인데 outer 조인 사용하는 경우 많음
- foreign key 사용 자제
    - mysql에서는 fk 잘 사용안함
    - 가비지 데이터 줄이고 신뢰 높일 수 있지만
    - 부모테이블에서 값이 있는지 없는지 확인하기 때문에 속도가 저하됨
    - 추후 담당자 변경통해 관리 어려워져서 사용 자제
- limit의 성능
    - offset 1000일때(limit 1000,10)인 경우 1010row를 스캔하게됨
    - 이런경우 PK 조건 추가해서 범위 줄인다음에 limit 사용
    - 즉, where 문에서 1000이상만 조회하도록 한 뒤에, limit을 10만 지정
- group by
    - 중복제거를 목적으로 모든 컬럼 들어가지 않음
    - select 절에 명시한 컬럼 모두 들어가지 않을경우 오류 발생 가능성
- group by는 정렬이 자동으로 발생하는데 order by 사용
- join의 조건을 where에 넣지 않고, on에 명시


### 질문 정리
- 적합한 인덱스를 확인해주는 툴이 있는지? : 없음
- inner 조인 vs from에서 테이블 두개를 넣고 where 사용
    - inner 조인을 주로 사용
    - 첫번째 이유 : ANSI SQL의 표준
    - 두번째 이유 : 동작은 같지만. 사람의 실수가 발생할 수 있음
        - where는 검색조건만 들어가서 가독성이 좋음
- fk 사용하지 않으면 테이블 간 관계을 어떻게 설정
    - 디비에서 별도로 테이블 간 관계를 설정하지 않음
    - 모델링에서만 관계를 지정해주면 됨
    - update 시 정합성 체크는 개발쪽에서 별도로 해줘야함
- 디비에서 데이터 가져올때 가공해서 불러오는지, 가져와서 가공하는지
    - DBA의 입장에서는 디비의 부하를 줄이는 것이 좋음
    - 쿼리가 너무 성능이 안나올때 개발쪽에서 가공


